<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=icon href=/fav.png type=image/png><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora&family=Muli:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto&family=Muli:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora&family=Muli:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto&family=Muli:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora&family=Muli:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto&family=Muli:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:title" content="WeakEvents in PCLs"><meta property="og:description" content="One of the biggest causes of memory leaks I&rsquo;ve seen in C# applications is events. Although C# can&rsquo;t leak in the same way C++ can, it&rsquo;s easy to unintentionally end up with references you weren&rsquo;t expecting - and what a lot of people don&rsquo;t realise or forget is that subscribing to an event holds a reference from the event source to the event target, essentially keeping the target alive.
A simple example is when you have a long lived object:"><meta property="og:type" content="article"><meta property="og:url" content="https://jimbobbennett.dev/blogs/weakevents-in-pcls/"><meta property="og:image" content="https://jimbobbennett.dev/blogs/weakevents-in-pcls/banner.png"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2014-09-07T08:05:45+00:00"><meta property="article:modified_time" content="2014-09-07T08:05:45+00:00"><meta property="og:site_name" content="JimBobBennett"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jimbobbennett.dev/blogs/weakevents-in-pcls/banner.png"><meta name=twitter:title content="WeakEvents in PCLs"><meta name=twitter:description content="One of the biggest causes of memory leaks I&rsquo;ve seen in C# applications is events. Although C# can&rsquo;t leak in the same way C++ can, it&rsquo;s easy to unintentionally end up with references you weren&rsquo;t expecting - and what a lot of people don&rsquo;t realise or forget is that subscribing to an event holds a reference from the event source to the event target, essentially keeping the target alive.
A simple example is when you have a long lived object:"><meta name=twitter:site content="@jimbobbennett"><meta name=twitter:creator content="@jimbobbennett"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css integrity=sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3 crossorigin=anonymous><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><link rel="shortcut icon" type=image/png href=/fav.png><link rel="shortcut icon" sizes=192x192 href=/fav.png><link rel=apple-touch-icon href=/fav.png><link rel=alternate type=application/rss+xml href=https://jimbobbennett.dev/index.xml title=JimBobBennett><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","dctc2ydykv")</script><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--background-color:#000;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--background-color-dark:#000000;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{background-color:#000;font-size:1rem;font-weight:400;line-height:1.5;text-align:left}</style><meta name=description content><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/single.css><link rel=stylesheet href=/css/projects.css media=all><script defer src=/fontawesome-5/all-5.15.4.js></script><title>WeakEvents in PCLs | JimBobBennett</title></head><body class=light onload=loading()><header><nav class="pt-3 navbar navbar-expand-lg"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/fav.png width=30 height=30 class="d-inline-block align-top">
JimBobBennett</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text"><a class=nav-link href=/ aria-label=home>Home</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#projects aria-label=projects>Recent Highlights</a></li><li class="nav-item navbar-text"><a class=nav-link href=/blogs title="Blog posts">Blog</a></li><li class="nav-item navbar-text"><a class=nav-link href=/videos title=Videos>Videos</a></li><li class="nav-item navbar-text"><a class=nav-link href=/livestreams title=Livestreams>Livestreams</a></li><li class="nav-item navbar-text"><a class=nav-link href=/conferences title=Conferences>Conferences</a></li><li class="nav-item navbar-text"><a class=nav-link href=/resume title=Resume>Resume</a></li></ul></div></div></nav></header><div id=content><section id=projects><div class="container pt-5" id=list-page><div class="row justify-content-center px-3 px-md-5"><h1 class="text-left pb-2 content">WeakEvents in PCLs</h1><div class="text-left content">Jim Bennett
<small>|</small>
Sep 7, 2014</div></div></div></section><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><article class="page-content p-2"><p>One of the biggest causes of memory leaks I&rsquo;ve seen in C# applications is events. Although C# can&rsquo;t leak in the same way C++ can, it&rsquo;s easy to unintentionally end up with references you weren&rsquo;t expecting - and what a lot of people don&rsquo;t realise or forget is that subscribing to an event holds a reference from the event source to the event target, essentially keeping the target alive.</p><p>A simple example is when you have a long lived object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FooManager</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> EventHandler FooEvent;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and subscribe from something like a model that is only meant to live for the lifetime of a popup window or other short lived object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShortLivedModel</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> ShortLivedModel(FooManager fm)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    	fm.FooEvent += FooHandler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> FooHandler(<span style=color:#66d9ef>object</span> sender, EventArgs args)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Just by doing this the <code>FooManager</code> internally holds a reference to the <code>FooModel</code> keeping it alive. If you create one model each time the window is popped up you can very quickly build up a big leak, especially if the view model holds onto the model, and the view holds onto the view model - that one model keeps a massic object graph alive.</p><p>So how do we deal with it?</p><p>The best option is to remember to unsubscribe. But this isn&rsquo;t always easy. Especially with WPF code there is no simple way to see when a control is closed if it&rsquo;s not a window. It&rsquo;s also easy to forget, especially in complicated code where the event subscription could be in a base class you don&rsquo;t know about or don&rsquo;t have access to.</p><p>There is an easier way - weak events. These don&rsquo;t hold a reference to the target allowing the target to be GC&rsquo;d without unsubscribing. Even better , you can use them in the event implementation making it transparent to the subscriber. This is quite a standard pattern and Microsoft provides a good implementation of both a <a href="http://msdn.microsoft.com/en-us/library/system.windows.weakeventmanager%28v=vs.110%29.aspx">specific</a> and <a href="http://msdn.microsoft.com/en-us/library/hh199438%28v=vs.110%29.aspx">generic</a> weak event manager. The problem with these is that they don&rsquo;t work for PCL projects - they are too heavily linked to reflection.</p><p>Luckily it&rsquo;s not that hard to create your own that is PCL compliant.</p><p>The pattern I&rsquo;m going to use is to change the event implementation to wire the target of the event into the weak event manager, then tell the weak event manager to fire the event when needed.</p><p>Lets start with the calling code first, then build up the weak event manager from there.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> WeakEventManager _manager = <span style=color:#66d9ef>new</span> WeakEventManager();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> EventHandler MyEvent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>add</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _manager.AddEventHandler(<span style=color:#e6db74>&#34;MyEvent&#34;</span>, <span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>remove</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _manager.RemoveEventHandler(<span style=color:#e6db74>&#34;MyEvent&#34;</span>, <span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#66d9ef>void</span> OnMyEvent()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _manager.HandleEvent(<span style=color:#66d9ef>this</span>, EventArgs.Empty, <span style=color:#e6db74>&#34;MyEvent&#34;</span>);    
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the above code we are declaring a <code>WeakEventManager</code>, then wiring up the value passed to the add handler for the event to it. When we want to invoke our event we tell the <code>WeakEventManager</code> to invoke the event by name with whatever sender and args we require.</p><p>Lets look at the implementation now. The full code contains thread safety, a static to get one manager per source object and other helpful bits. The code here is just the basics for brevity.</p><p><strong>First, adding the event handlers.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WeakEventManager</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt;&gt; _eventHandlers = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt;&gt;();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddEventHandler&lt;TEventArgs&gt;(<span style=color:#66d9ef>string</span> eventName, EventHandler&lt;TEventArgs&gt; <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>where</span> TEventArgs : EventArgs
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        BuildEventHandler(eventName, <span style=color:#66d9ef>value</span>.Target, <span style=color:#66d9ef>value</span>.GetMethodInfo());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddEventHandler(<span style=color:#66d9ef>string</span> eventName, EventHandler <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        BuildEventHandler(eventName, <span style=color:#66d9ef>value</span>.Target, <span style=color:#66d9ef>value</span>.GetMethodInfo());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> BuildEventHandler(<span style=color:#66d9ef>string</span> eventName, <span style=color:#66d9ef>object</span> handlerTarget, MethodInfo methodInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt; target;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!_eventHandlers.TryGetValue(eventName, <span style=color:#66d9ef>out</span> target))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            target = <span style=color:#66d9ef>new</span> List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt;();
</span></span><span style=display:flex><span>            _eventHandlers.Add(eventName, target);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        target.Add(Tuple.Create(<span style=color:#66d9ef>new</span> WeakReference(handlerTarget), methodInfo));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are 2 <code>AddEventHandler</code> methods to cover events that are of type <code>EventHandler</code> and those of type <code>EventHandler&lt;args></code>. Both route through to the same helper but are needed as they are not convertible.
The code here has a dictionary of a list of handlers and targets to the event name. Each item in the list contains the <code>MethodInfo</code> of the handler (lambdas still have method info so they can be used as the event target) allowing the invocator to call the method, and a weak reference to the target so we know what to call the method on. The weak reference bit is important here. We don&rsquo;t want to keep a string reference as that would keep the target alive - the thing we&rsquo;re trying to avoid!
For each call we add the passed in handler and a weak reference to it&rsquo;s target to the list held against the event name. Notice no type safety with the event names. There is nothing that validates that the name given is an event on the source object - the manager doesn&rsquo;t even know what the source object is! This provides to my mind greater flexibility so the manager can also be used as an event broker.</p><p><strong>Next, the event invocator.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> HandleEvent(<span style=color:#66d9ef>object</span> sender, <span style=color:#66d9ef>object</span> args, <span style=color:#66d9ef>string</span> eventName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toRaise = <span style=color:#66d9ef>new</span> List&lt;Tuple&lt;<span style=color:#66d9ef>object</span>, MethodInfo&gt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt; target;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_eventHandlers.TryGetValue(eventName, <span style=color:#66d9ef>out</span> target))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> tuple <span style=color:#66d9ef>in</span> target.ToList())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> o = tuple.Item1.Target;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (o == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            	target.Remove(tuple);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            	toRaise.Add(Tuple.Create(o, tuple.Item2));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> tuple <span style=color:#66d9ef>in</span> toRaise)
</span></span><span style=display:flex><span>        tuple.Item2.Invoke(tuple.Item1, <span style=color:#66d9ef>new</span>[] {sender, args});
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code finds the event with the given name in the dictionary, and if it finds it works through the list of handlers. Each target in the list is evaluated to see if it&rsquo;s null or not. With a <code>WeakReference</code>, the <code>Target</code> returns null if it has been GC&rsquo;d. There is an <code>IsAlive</code> method but this is pretty useless as there is a race condition, it could be GC&rsquo;d between the call to <code>IsAlive</code> and the call to <code>Target</code>. The best way is to get a reference to the target, if the target is null the reference is null and if the target is not null the reference stops it being GC&rsquo;d until we&rsquo;ve finished using it.
If the target is null, we remove the item from the list and carry on. If it&rsquo;s not null, we store it in a list to invoke at the end.
Once we have all the alive handlers, we loop through them invoking the method on the target.</p><p><strong>Lastly, we need the remove code.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveEventHandler&lt;TEventArgs&gt;(<span style=color:#66d9ef>string</span> eventName, EventHandler&lt;TEventArgs&gt; <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> TEventArgs : EventArgs
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    RemoveEventHandlerImpl(eventName, <span style=color:#66d9ef>value</span>.Target, <span style=color:#66d9ef>value</span>.GetMethodInfo());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveEventHandler(<span style=color:#66d9ef>string</span> eventName, EventHandler <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    RemoveEventHandlerImpl(eventName, <span style=color:#66d9ef>value</span>.Target, <span style=color:#66d9ef>value</span>.GetMethodInfo());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> RemoveEventHandlerImpl(<span style=color:#66d9ef>string</span> eventName, <span style=color:#66d9ef>object</span> handlerTarget, MemberInfo methodInfo)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    List&lt;Tuple&lt;WeakReference, MethodInfo&gt;&gt; target;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_eventHandlers.TryGetValue(eventName, <span style=color:#66d9ef>out</span> target))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> tuple <span style=color:#66d9ef>in</span> target.Where(t =&gt; t.Item1.Target == handlerTarget &amp;&amp;
</span></span><span style=display:flex><span>            t.Item2.Name == methodInfo.Name).ToList())
</span></span><span style=display:flex><span>            target.Remove(tuple);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This just loops through the list against the event name and removes the entries for the given target and method name. This is needed to ensure intentionaly unsubscribing from the events works but as mentioned above is not needed to allow the target to be GC&rsquo;d.</p><p>The full code for this is on <a href=https://github.com/jimbobbennett/JimLib/blob/master/JimLib/Events/WeakEventManager.cs>GitHub</a> and it&rsquo;s part of the <a href=https://www.nuget.org/packages/JimBobBennett.JimLib/>JimLib NuGet package</a>.</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents></nav></div></aside><aside class=tags><h5>Tags</h5><ul class="tags-ul list-unstyled list-inline"><li class=list-inline-item><a href=https://jimbobbennett.dev/tags/technology target=_blank>Technology</a></li><li class=list-inline-item><a href=https://jimbobbennett.dev/tags/pcl target=_blank>pcl</a></li><li class=list-inline-item><a href=https://jimbobbennett.dev/tags/jimlib target=_blank>jimlib</a></li><li class=list-inline-item><a href=https://jimbobbennett.dev/tags/weak-events target=_blank>weak events</a></li><li class=list-inline-item><a href=https://jimbobbennett.dev/tags/memory-leak target=_blank>memory leak</a></li></ul></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://jimbobbennett.dev/blogs/weakevents-in-pcls/",this.page.identifier="9c71b7f02f5c5e5439eca85264a954ff"};(function(){if(window.location.hostname=="localhost")return;var e=document,t=e.createElement("script");t.src="https://jimbobbennett.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></div><footer><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center">&copy; 2022 All Rights Reserved</div></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js integrity=sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13 crossorigin=anonymous></script>
<script>document.body.className.includes("light")&&(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))</script><script>let loadingIcons;function loading(){myVar=setTimeout(showPage,100)}function showPage(){try{document.getElementById("loading-icons").style.display="block"}catch{}}</script><script>function createCopyButton(e,t){const n=document.createElement("button");n.className="copy-code-button",n.type="button",n.innerText="Copy",n.addEventListener("click",()=>copyCodeToClipboard(n,e,t)),addCopyButtonToDom(n,e)}async function copyCodeToClipboard(e,t,n){const s=t.querySelector("pre > code").innerText;try{n.writeText(s)}finally{codeWasCopied(e)}}function codeWasCopied(e){e.blur(),e.innerText="Copied!",setTimeout(function(){e.innerText="Copy"},2e3)}function addCopyButtonToDom(e,t){t.insertBefore(e,t.firstChild);const n=document.createElement("div");n.className="highlight-wrapper",t.parentNode.insertBefore(n,t),n.appendChild(t)}if(navigator&&navigator.clipboard)document.querySelectorAll(".highlight").forEach(e=>createCopyButton(e,navigator.clipboard));else{var script=document.createElement("script");script.src="https://cdnjs.cloudflare.com/ajax/libs/clipboard-polyfill/2.7.0/clipboard-polyfill.promise.js",script.integrity="sha256-waClS2re9NUbXRsryKoof+F9qc1gjjIhc2eT7ZbIv94=",script.crossOrigin="anonymous",script.onload=function(){addCopyButtons(clipboard)},document.querySelectorAll(".highlight").forEach(e=>createCopyButton(e,script)),document.body.appendChild(script)}</script></body></html>